<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cluster Finding</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Lora:ital,wght@0,400;0,500;0,600;1,400&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f8fafc; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        
        body { 
            background-color: #ffffff; 
            color: #222222; 
        }
        .font-sans { font-family: 'Inter', -apple-system, sans-serif; }
        .font-serif { font-family: 'Lora', Georgia, serif; }

        #canvas-container {
            width: 100%;
            height: 55vh;
            min-height: 400px;
            max-height: 600px;
            position: relative;
        }
        canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 0.5rem;
            background-color: #ffffff;
            border: 1px solid #e2e8f0;
        }
        
        select {
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1em;
        }
    </style>
</head>
<body class="min-h-screen antialiased selection:bg-blue-100 selection:text-blue-900 flex flex-col items-center py-8 md:py-10 px-5 md:px-8">

    <div class="w-full max-w-4xl flex-grow flex flex-col">
        
        <!-- Header -->
        <header class="mb-6 flex flex-col items-start">
            <div class="flex items-center gap-3 mb-3">
                <a href="index.html" class="group shrink-0 block" title="Back to Hub">
                    <img src="logo.png" alt="Mímisbrunnr Logo" class="w-10 h-10 rounded-lg object-cover border border-slate-200 grayscale opacity-80 group-hover:grayscale-0 group-hover:opacity-100 transition-all duration-300">
                </a>
                <h1 class="font-serif text-3xl md:text-4xl font-medium text-slate-900">Cluster Finding</h1>
            </div>
            <div class="font-sans text-[10px] font-bold uppercase tracking-widest text-slate-400 mb-2">Machine Learning &bull; Unsupervised</div>
            <p class="font-serif text-sm md:text-base text-slate-600 leading-snug">Discover hidden structures and group data using different geometric assumptions.</p>
        </header>

        <hr class="border-slate-100 mb-6">

        <!-- Control Panel -->
        <div class="flex flex-col gap-6 mb-8">
            
            <div class="flex flex-col md:flex-row gap-5 justify-between items-start md:items-end">
                
                <!-- Data Selection -->
                <div class="flex flex-col gap-1.5 w-full md:w-1/3">
                    <label for="data-select" class="font-sans text-[10px] font-bold text-slate-500 uppercase tracking-widest">1. Data Distribution</label>
                    <select id="data-select" class="font-sans bg-white border border-slate-300 text-slate-800 text-sm rounded-md focus:ring-blue-500 focus:border-blue-500 block w-full p-2 cursor-pointer transition-colors hover:bg-slate-50 outline-none">
                        <option value="blobs">Standard Blobs (3 Clusters)</option>
                        <option value="moons">Interlocking Moons</option>
                        <option value="circles">Concentric Circles</option>
                        <option value="uniform">Uniform Noise</option>
                    </select>
                </div>

                <!-- Algorithm Selection -->
                <div class="flex flex-col gap-1.5 w-full md:w-1/3">
                    <label for="algo-select" class="font-sans text-[10px] font-bold text-slate-500 uppercase tracking-widest">2. Algorithm</label>
                    <select id="algo-select" class="font-sans bg-white border border-slate-300 text-slate-800 text-sm rounded-md focus:ring-blue-500 focus:border-blue-500 block w-full p-2 cursor-pointer transition-colors hover:bg-slate-50 outline-none font-semibold">
                        <option value="kmeans">K-Means (Centroid-based)</option>
                        <option value="dbscan">DBSCAN (Density-based)</option>
                    </select>
                </div>

                <!-- Action Buttons -->
                <div class="flex gap-2 w-full md:w-auto">
                    <button id="btn-reset" class="font-sans flex-1 md:flex-none bg-white hover:bg-slate-50 text-slate-700 text-sm font-medium py-2 px-4 rounded-md transition-colors border border-slate-300">
                        Reset
                    </button>
                    <button id="btn-start" class="font-sans flex-1 md:flex-none bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium py-2 px-6 rounded-md transition-colors border border-transparent">
                        Run Clustering
                    </button>
                </div>
            </div>

            <!-- Dynamic Hyperparameters Panel -->
            <div class="bg-slate-50 p-4 rounded-md border border-slate-200">
                <h3 class="font-sans text-[10px] font-bold text-slate-400 uppercase tracking-widest mb-3">3. Hyperparameters</h3>
                
                <!-- K-Means Params -->
                <div id="params-kmeans" class="flex flex-col md:flex-row gap-6 transition-opacity duration-300">
                    <div class="flex flex-col gap-1.5 w-full md:w-64">
                        <label class="font-sans text-xs font-medium text-slate-700 flex justify-between">
                            <span>Number of Clusters (K)</span><span id="label-k" class="text-blue-600 font-bold">3</span>
                        </label>
                        <input type="range" id="slider-k" min="1" max="8" value="3" class="w-full accent-blue-600">
                        <p class="font-serif text-xs text-slate-500 mt-1">How many centroids to initialize.</p>
                    </div>
                </div>

                <!-- DBSCAN Params -->
                <div id="params-dbscan" class="flex flex-col md:flex-row gap-6 hidden transition-opacity duration-300">
                    <div class="flex flex-col gap-1.5 w-full md:w-64">
                        <label class="font-sans text-xs font-medium text-slate-700 flex justify-between">
                            <span>Epsilon (Radius)</span><span id="label-eps" class="text-blue-600 font-bold">0.15</span>
                        </label>
                        <input type="range" id="slider-eps" min="0.05" max="0.5" step="0.01" value="0.15" class="w-full accent-blue-600">
                        <p class="font-serif text-xs text-slate-500 mt-1">Maximum distance between points.</p>
                    </div>
                    <div class="flex flex-col gap-1.5 w-full md:w-64">
                        <label class="font-sans text-xs font-medium text-slate-700 flex justify-between">
                            <span>Min Points</span><span id="label-minpts" class="text-blue-600 font-bold">4</span>
                        </label>
                        <input type="range" id="slider-minpts" min="2" max="15" value="4" class="w-full accent-blue-600">
                        <p class="font-serif text-xs text-slate-500 mt-1">Minimum neighbors to form a core.</p>
                    </div>
                </div>
            </div>
            
            <!-- Description Box -->
            <div class="font-serif text-sm text-slate-700 leading-relaxed border-l-2 border-blue-200 pl-3 py-0.5" id="algo-desc">
                <!-- Filled dynamically -->
            </div>

        </div>

        <!-- Canvas Container -->
        <div id="canvas-container" class="mb-6">
            <canvas id="clusterCanvas"></canvas>
        </div>

        <!-- FOOTER -->
        <footer class="mt-auto pt-4 border-t border-slate-200 flex flex-col md:flex-row justify-between items-center gap-3">
            <div class="font-sans text-[10px] font-medium text-slate-400 tracking-wide uppercase flex items-center gap-1.5">
                <span>Built with ☕ by <a href="https://github.com/sambit-giri" target="_blank" class="text-slate-500 hover:text-slate-900 transition-colors">Sambit Giri</a></span>
                <span>&bull;</span>
                <span>MIT License</span>
            </div>
            <div class="flex gap-4 items-center">
                <a href="index.html" class="font-sans text-xs font-medium text-slate-500 hover:text-blue-600 transition-colors flex items-center gap-1">
                    &larr; Back to Hub
                </a>
            </div>
        </footer>

    </div>

    <script>
        // DOM Elements
        const canvas = document.getElementById('clusterCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        
        const dataSelect = document.getElementById('data-select');
        const algoSelect = document.getElementById('algo-select');
        const btnReset = document.getElementById('btn-reset');
        const btnStart = document.getElementById('btn-start');
        
        const paramsKMeans = document.getElementById('params-kmeans');
        const paramsDBSCAN = document.getElementById('params-dbscan');
        const algoDesc = document.getElementById('algo-desc');
        
        const sliderK = document.getElementById('slider-k');
        const sliderEps = document.getElementById('slider-eps');
        const sliderMinPts = document.getElementById('slider-minpts');
        
        const labelK = document.getElementById('label-k');
        const labelEps = document.getElementById('label-eps');
        const labelMinPts = document.getElementById('label-minpts');

        // State Variables
        let points = [];
        let centroids = [];
        let isRunning = false;
        let currentRunId = 0;
        
        // Colors palette for clusters
        const PALETTE = [
            '#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', 
            '#ec4899', '#06b6d4', '#f97316', '#6366f1', '#14b8a6'
        ];
        const UNASSIGNED_COLOR = '#cbd5e1'; 
        const NOISE_COLOR = '#1e293b';      

        // Utility Math
        const randn = () => {
            let u = 0, v = 0;
            while(u === 0) u = Math.random();
            while(v === 0) v = Math.random();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        };
        const distance = (p1, p2) => Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
        const sleep = (ms, runId) => new Promise((res, rej) => {
            setTimeout(() => { if(runId === currentRunId) res(); else rej("Aborted"); }, ms);
        });

        // --- DATA GENERATORS (Generate points in normalized -1.5 to 1.5 space) ---
        const NUM_POINTS = 300;

        function generateData() {
            currentRunId++; // Cancel active animations
            points = [];
            centroids = [];
            const type = dataSelect.value;
            
            if (type === 'blobs') {
                const centers = [{x: -0.6, y: -0.6}, {x: 0.6, y: -0.6}, {x: 0, y: 0.7}];
                for (let i = 0; i < NUM_POINTS; i++) {
                    const center = centers[i % 3];
                    points.push({
                        x: center.x + randn() * 0.15,
                        y: center.y + randn() * 0.15,
                        cluster: -1, isNoise: false
                    });
                }
            } else if (type === 'moons') {
                for (let i = 0; i < NUM_POINTS; i++) {
                    const isTop = i % 2 === 0;
                    const theta = Math.random() * Math.PI;
                    const noiseX = randn() * 0.08;
                    const noiseY = randn() * 0.08;
                    if (isTop) {
                        points.push({ x: Math.cos(theta) - 0.5 + noiseX, y: Math.sin(theta) - 0.2 + noiseY, cluster: -1, isNoise: false });
                    } else {
                        points.push({ x: 1 - Math.cos(theta) - 0.5 + noiseX, y: 0.5 - Math.sin(theta) - 0.2 + noiseY, cluster: -1, isNoise: false });
                    }
                }
            } else if (type === 'circles') {
                for (let i = 0; i < NUM_POINTS; i++) {
                    const isInner = i % 3 === 0; 
                    const r = isInner ? 0.3 : 0.8;
                    const theta = Math.random() * 2 * Math.PI;
                    const noiseX = randn() * 0.05;
                    const noiseY = randn() * 0.05;
                    points.push({ x: r * Math.cos(theta) + noiseX, y: r * Math.sin(theta) + noiseY, cluster: -1, isNoise: false });
                }
            } else if (type === 'uniform') {
                for (let i = 0; i < NUM_POINTS; i++) {
                    points.push({
                        x: (Math.random() * 2.4) - 1.2,
                        y: (Math.random() * 2.4) - 1.2,
                        cluster: -1, isNoise: false
                    });
                }
            }
            
            draw();
            setRunningState(false);
        }

        // --- DRAWING LOGIC ---
        function resizeCanvas() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            draw();
        }
        window.addEventListener('resize', resizeCanvas);

        function mapToCanvas(x, y) {
            const scaleX = canvas.width / 3;
            const scaleY = canvas.height / 3;
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            return { px: cx + x * scaleX, py: cy - y * scaleY };
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            points.forEach(p => {
                const {px, py} = mapToCanvas(p.x, p.y);
                ctx.beginPath();
                ctx.arc(px, py, 4, 0, 2 * Math.PI);
                
                if (p.isNoise) {
                    ctx.fillStyle = NOISE_COLOR;
                } else if (p.cluster === -1) {
                    ctx.fillStyle = UNASSIGNED_COLOR;
                } else {
                    ctx.fillStyle = PALETTE[p.cluster % PALETTE.length];
                }
                
                ctx.fill();
            });

            centroids.forEach((c, idx) => {
                const {px, py} = mapToCanvas(c.x, c.y);
                ctx.beginPath();
                ctx.moveTo(px - 8, py - 8); ctx.lineTo(px + 8, py + 8);
                ctx.moveTo(px + 8, py - 8); ctx.lineTo(px - 8, py + 8);
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 4;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(px - 8, py - 8); ctx.lineTo(px + 8, py + 8);
                ctx.moveTo(px + 8, py - 8); ctx.lineTo(px - 8, py + 8);
                ctx.strokeStyle = PALETTE[idx % PALETTE.length];
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        // --- ALGORITHMS ---
        
        function setRunningState(running) {
            isRunning = running;
            btnStart.disabled = running;
            dataSelect.disabled = running;
            algoSelect.disabled = running;
            if(running) {
                btnStart.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                btnStart.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        async function runClustering() {
            currentRunId++;
            const runId = currentRunId;
            setRunningState(true);
            
            points.forEach(p => { p.cluster = -1; p.isNoise = false; });
            centroids = [];
            draw();

            try {
                if (algoSelect.value === 'kmeans') {
                    await runKMeans(runId);
                } else if (algoSelect.value === 'dbscan') {
                    await runDBSCAN(runId);
                }
            } catch (error) {
                if (error !== "Aborted") console.error(error);
            } finally {
                if (runId === currentRunId) setRunningState(false);
            }
        }

        async function runKMeans(id) {
            const K = parseInt(sliderK.value);
            
            for(let i=0; i<K; i++) {
                const rp = points[Math.floor(Math.random() * points.length)];
                centroids.push({x: rp.x, y: rp.y});
            }
            draw(); await sleep(500, id);

            let changed = true;
            let maxIters = 20;

            while (changed && maxIters > 0) {
                changed = false;
                maxIters--;

                points.forEach(p => {
                    let minDist = Infinity;
                    let bestCluster = -1;
                    centroids.forEach((c, idx) => {
                        const d = distance(p, c);
                        if (d < minDist) { minDist = d; bestCluster = idx; }
                    });
                    if (p.cluster !== bestCluster) changed = true;
                    p.cluster = bestCluster;
                });
                
                draw(); await sleep(600, id);

                const newSums = Array(K).fill(null).map(() => ({x: 0, y: 0, count: 0}));
                points.forEach(p => {
                    if(p.cluster !== -1) {
                        newSums[p.cluster].x += p.x;
                        newSums[p.cluster].y += p.y;
                        newSums[p.cluster].count += 1;
                    }
                });

                centroids.forEach((c, idx) => {
                    if (newSums[idx].count > 0) {
                        c.x = newSums[idx].x / newSums[idx].count;
                        c.y = newSums[idx].y / newSums[idx].count;
                    }
                });

                draw(); await sleep(600, id);
            }
        }

        async function runDBSCAN(id) {
            const eps = parseFloat(sliderEps.value);
            const minPts = parseInt(sliderMinPts.value);
            
            const visited = new Set();
            let currentCluster = 0;

            const getNeighbors = (p) => {
                return points.filter(other => distance(p, other) <= eps);
            };

            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                if (visited.has(p)) continue;
                
                visited.add(p);
                const neighbors = getNeighbors(p);

                if (neighbors.length < minPts) {
                    p.isNoise = true; 
                    draw(); await sleep(20, id);
                } else {
                    p.cluster = currentCluster;
                    p.isNoise = false;
                    draw(); await sleep(20, id);

                    let seeds = [...neighbors];
                    let sIdx = 0;
                    
                    while (sIdx < seeds.length) {
                        const q = seeds[sIdx];
                        if (!visited.has(q)) {
                            visited.add(q);
                            const qNeighbors = getNeighbors(q);
                            if (qNeighbors.length >= minPts) {
                                qNeighbors.forEach(qn => {
                                    if(!seeds.includes(qn)) seeds.push(qn);
                                });
                            }
                        }
                        if (q.cluster === -1 || q.isNoise) {
                            q.cluster = currentCluster;
                            q.isNoise = false;
                            
                            if (sIdx % 3 === 0) {
                                draw(); await sleep(20, id);
                            }
                        }
                        sIdx++;
                    }
                    currentCluster++;
                    draw(); await sleep(50, id);
                }
            }
            draw();
        }

        function updateUI() {
            const algo = algoSelect.value;
            
            if (algo === 'kmeans') {
                paramsKMeans.classList.remove('hidden');
                paramsDBSCAN.classList.add('hidden');
                algoDesc.innerHTML = "<strong class='font-sans text-xs text-slate-800 uppercase tracking-widest block mb-1'>K-Means</strong> Assumes clusters are spherical and evenly sized. It tries to find the center (centroid) of each cluster. <em>Notice how it fails on Moons and Concentric Circles because it relies entirely on straight-line distance to a center point.</em>";
            } else {
                paramsKMeans.classList.add('hidden');
                paramsDBSCAN.classList.remove('hidden');
                algoDesc.innerHTML = "<strong class='font-sans text-xs text-slate-800 uppercase tracking-widest block mb-1'>DBSCAN</strong> Density-Based Spatial Clustering. Groups together points that are closely packed, and marks points in low-density areas as outliers (black). <em>Beautifully handles complex shapes like Moons without needing to know the number of clusters in advance.</em>";
            }
            
            labelK.textContent = sliderK.value;
            labelEps.textContent = sliderEps.value;
            labelMinPts.textContent = sliderMinPts.value;
        }

        algoSelect.addEventListener('change', updateUI);
        sliderK.addEventListener('input', updateUI);
        sliderEps.addEventListener('input', updateUI);
        sliderMinPts.addEventListener('input', updateUI);
        
        dataSelect.addEventListener('change', generateData);
        btnReset.addEventListener('click', generateData);
        btnStart.addEventListener('click', runClustering);

        updateUI();
        resizeCanvas();
        generateData();

    </script>
</body>
</html>